
import { pgTable, uuid, varchar, jsonb, integer, text, timestamp, boolean, pgEnum } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm/relations';

// --- ENUMS AND TYPES ---
export const tierEnum = pgEnum('tier', ['free', 'core', 'premium']);
export const appStateEnum = pgEnum('app_state', ['onboarding', 'dashboard']);
export const moodEnum = pgEnum('mood', ['Happy', 'Calm', 'Energetic', 'Tired', 'Anxious', 'Okay', 'Stressed']);
export const confidenceEnum = pgEnum('confidence', ['high', 'medium', 'low']);
export const trendEnum = pgEnum('trend', ['improving', 'stable', 'declining']);
export const feedbackEnum = pgEnum('feedback', ['helpful', 'not_helpful']);


export type UserSettings = {
  name: string;
  theme: 'light' | 'dark';
  remindersEnabled: boolean;
  reminderTime: string;
  customPrompts: string[];
  focusAreas: string[];
};

export type PartnerAccess = {
  enabled: boolean;
  partnerEmail: string | null;
};

// --- TABLES ---

export const users = pgTable('users', {
    id: varchar('id', { length: 255 }).primaryKey(), // Supabase auth user ID
    tier: tierEnum('tier').default('free').notNull(),
    appState: appStateEnum('app_state').default('onboarding').notNull(),
    settings: jsonb('settings').default({ name: 'User', theme: 'light', remindersEnabled: true, reminderTime: '08:00', customPrompts: [], focusAreas: [] }).$type<UserSettings>().notNull(),
    partnerAccess: jsonb('partner_access').default({ enabled: false, partnerEmail: null }).$type<PartnerAccess>().notNull(),
    currentStreak: integer('current_streak').default(0).notNull(),
    lastLogDate: varchar('last_log_date', { length: 10 }).default('').notNull(), // YYYY-MM-DD
    createdAt: timestamp('created_at').defaultNow().notNull(),
});

/**
 * == Data Persistence Contract: User Logs ==
 * Stores daily, user-provided observations. Each user has at most one log entry per calendar day.
 *
 * - Table: `logs`
 * - Data Management: Entries are created or updated (upserted) daily via the `saveLog` API function.
 *   This ensures data integrity by preventing duplicate entries for the same day.
 *
 * Schema:
 * - `id` (uuid, pk): Unique identifier for the log entry.
 * - `userId` (varchar, fk): Associates the log with a user. Cascades on delete.
 * - `date` (varchar): The calendar date of the log in 'YYYY-MM-DD' format. A unique constraint with `userId` is enforced at the application level.
 * - `mood` (moodEnum, optional): The user's self-reported mood for the day.
 * - `sleep` (integer, optional): User's self-reported sleep quality on a scale of 1-5.
 * - `note` (text, optional): A free-text field for journaling or notes.
 * - `sensations` (jsonb, optional): An array of strings storing any physical sensations reported (e.g., "Headache", "Fatigue").
 * - `createdAt`/`updatedAt` (timestamp): Automatic timestamps for record management.
 */
export const logs = pgTable('logs', {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: varchar('user_id', { length: 255 }).notNull().references(() => users.id, { onDelete: 'cascade' }),
    date: varchar('date', { length: 10 }).notNull(), // YYYY-MM-DD
    mood: moodEnum('mood'),
    sleep: integer('sleep'),
    note: text('note'),
    sensations: jsonb('sensations').$type<string[]>(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

/**
 * == Data Persistence Contract: AI Reflections ==
 * Stores AI-generated insights based on the user's recent log data.
 *
 * - Table: `reflections`
 * - Data Management: Generated by the `AIPoweredInsights` component. The `saveReflections` API function
 *   clears previous reflections for the user and inserts the new set. This ensures users only see the most current insights.
 *   The `feedback` field is updated by the user to help train the AI model.
 *
 * Schema:
 * - `id` (uuid, pk): Unique identifier for the reflection.
 * - `userId` (varchar, fk): Associates the reflection with a user.
 * - `dateGenerated` (varchar): The 'YYYY-MM-DD' date the reflection was created.
 * - `title` (text): The main title of the insight (e.g., "A Link Between Sleep and Mood").
 * - `description` (text): The detailed explanation of the observed pattern.
 * - `confidence` (confidenceEnum): The AI's confidence level ('high', 'medium', 'low') in the insight.
 * - `trend` (trendEnum): The observed trend ('improving', 'stable', 'declining').
 * - `feedback` (feedbackEnum, optional): User-provided feedback ('helpful', 'not_helpful').
 * - `createdAt` (timestamp): Timestamp of creation.
 */
export const reflections = pgTable('reflections', {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: varchar('user_id', { length: 255 }).notNull().references(() => users.id, { onDelete: 'cascade' }),
    dateGenerated: varchar('date_generated', { length: 10 }).notNull(),
    title: text('title').notNull(),
    description: text('description').notNull(),
    confidence: confidenceEnum('confidence').notNull(),
    trend: trendEnum('trend').notNull(),
    feedback: feedbackEnum('feedback'),
    createdAt: timestamp('created_at').defaultNow().notNull(),
});

export const milestones = pgTable('milestones', {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: varchar('user_id', { length: 255 }).notNull().references(() => users.id, { onDelete: 'cascade' }),
    days: integer('days').notNull(),
    dateAchieved: varchar('date_achieved', { length: 10 }).notNull(),
    celebrated: boolean('celebrated').default(false).notNull(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
});

/**
 * == Data Persistence Contract: Menstrual Cycles ==
 * Stores data related to the user's menstrual cycles.
 *
 * - Table: `cycles`
 * - Data Management: Managed via `logPeriodDay` and `removePeriodDay` API functions. A new cycle is automatically
 *   created if a period day is logged more than 20 days after the start of the previous cycle.
 *   The `periodDays` array is updated by adding or removing date strings.
 *
 * Schema:
 * - `id` (uuid, pk): Unique identifier for the cycle entry.
 * - `userId` (varchar, fk): Associates the cycle with a user.
 * - `startDate` (varchar): The first day of the cycle (which is the first day of the period) in 'YYYY-MM-DD' format.
 * - `periodDays` (jsonb): An array of 'YYYY-MM-DD' date strings representing the days of menstruation for that cycle.
 * - `createdAt` (timestamp): Timestamp of creation.
 */
export const cycles = pgTable('cycles', {
    id: uuid('id').primaryKey().defaultRandom(),
    userId: varchar('user_id', { length: 255 }).notNull().references(() => users.id, { onDelete: 'cascade' }),
    startDate: varchar('start_date', { length: 10 }).notNull(),
    periodDays: jsonb('period_days').$type<string[]>().notNull(), // Array of YYYY-MM-DD strings
    createdAt: timestamp('created_at').defaultNow().notNull(),
});

// --- RELATIONS ---

export const usersRelations = relations(users, ({ many }) => ({
	logs: many(logs),
    reflections: many(reflections),
    milestones: many(milestones),
    cycles: many(cycles),
}));

export const logsRelations = relations(logs, ({ one }) => ({
	author: one(users, {
		fields: [logs.userId],
		references: [users.id],
	}),
}));

// ... and so on for other tables if needed